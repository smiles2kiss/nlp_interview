1. Python 的回收机制，java的垃圾回收机制，C++的垃圾回收机制

2. Python装饰器，如何传参数到装饰器

3. Python迭代器

4. Python中dict的使用

5. 迭代器生成器差别

6. 多线程有哪些函数

7. 正则表达式match()和search()差别

8. yeild是什么，yield与return的区别

9. Python内部实现的多线程有什么问题(假的)

10. Python 线程安全/读写锁/智能指针

11. Python2 python3 中map的差别

12. Python动态加载模块

13. Python矩阵乘法

14. Python闭包

15. Python如何在类中修改全局变量

16. Python 中tuple、list、dict的区别

17. iterables、generator、yield的区别

18. Python中的三元运算符

19. Python内存管理，内存池最大？

20. Python可变和不可变数据结构

21. Python lamba与def 定义函数的区别

22. *arg, **kargs的用法

23. python中基本类型有哪些

24. 内置数据结构有哪些(tuple, list, dict, set), tuple与list有什么区别

25. Python的lambda表示式如何实现，写一个例子呢

26. C++和Python的区别，为什么C++比Python快，Python比C++好在哪里 (自动能实现内存回收机制)

27. 介绍Python的列表生成式

28. 用Python实现矩阵乘法，用Python实现矩阵乘法

29. Python中iterables、generator、yield的区别

30. Python常用数据结构

    Python的数据结构统称为容器，包括序列，映射和集合

    (1) **序列**: 序列都是有序的

    (2) **列表**: list(1, 2)

    * 列表是可变的，可增加
    * 由对其它对象的引用组成的连续数组实现
    * 指向这个数组的指针及其长度被保存在一个列表头结构中
    * 插入元素和删除元素的时间复杂度为O(n)

    (3) **元组**: tuple(1, 2), 元组是不可变的

    (4) **字符串**: string("abc"), 字符串是不可变的

    (5) **映射**

    * **字典**
      * 字典是可变容器
      * 字典是无序的
      * 字典查询、添加、删除元素的平均复杂度都为O(1)
      * 字典的键可以是数字、字符串或者是元组，键必须唯一
      * 字典是由哈希表实现
    * **哈希表**
      * 哈希表是由数组 + 链表构成
      * [hash, key, value]，首先计算hash(key)，再与字典最小长度与操作，得到一个index
      * 若index下标位置已经被占用，则会判断enteies的key是否与要插入的key是否相等
      * 如果key相等就表示key已存在，则更新value值
      * 如果key不相等，就表示hash冲突，则会继续向下寻找空位置，一直到找到剩余空位为止，然后将元素加入哈希表。
    * **集合**
      * 集合中的顺序是随意的
      * set(): 可变的、无序的、有限的集合
      * frozenset(): 一种不可变的、可哈希的、无序的集合

 

31. Python多线程

    (1) **多进程与多线程的区别**

    * 多进程中，**同一个变量，各自有一份拷贝存在于每个进程中**，互不影响
    * 多线程中，**所有变量都由所有线程共享**，所以，任何一个变量都可以被任何一个线程修改

    (2) **使用**

    * 调用多线程: import threading
    * 调用多进程: import multiprocessing

    (3) **线程锁Lock**

    * 多线程操作同一个资源（这里就是全局变量balance）的时候，需要加锁
    * lock在不同线程使用同一共享内存时，能够确保线程之间互不影响
    * 在每个线程执行运算修改共享内存之前，执行lock.acquire()将共享内存上锁， 确保当前线程执行时，内存不会被其他线程访问
    * 执行运算完毕后，使用lock.release()将锁打开， 保证其他的线程可以使用该共享内存

 

32. 全局解释器锁GIL

    **解释器被一个全局解释器锁保护着，它确保任何时候都只有一个Python线程执行**

    这点和C++不同，即使有多个CPU，Python每个线程在某个时间内也只能在一个CPU上运行

 