1. 给出一个整数n，要找重新组合后比n小，同时是组合后最大的数     例如 11，找不到 not found， 132 为123

2. 给出一个n的数组，求第一个未出现的数字，例如1     2 3 5 6 输出 4. 解法： 给一个n+3长度数组ret， if(输入数字大于n) continue，else     ret[数字]=1，然后遍历ret，看是那一个数字没有，返回该数字。有可能是返回n+1或者n+2,所以要设大一点.

3. 打印根号x (牛顿迭代法)

4. 输入n个进程id，寻找没出现过的最小进程号

5. K个有序链表合并成一个

6. 给定一个随意的正整数数组，求最长的连续数字长度 (桶排序，map优化)

7. 给定一个数组和一个数s，找到最短的子数组加起来的和超过s

8. 给定长度为n的数组，求所有可能长度为m的排列组合的情况

9. n个骰子扔一下，点数加起来等于m的概率
10. 判断一个区间是否能被给定的区间集合包含。
11. 螺旋数组
12. 无序数组中找第K大的数
13. 旋转数组查找k
14. 一个四位数abcd，满足abcd * 4 = dcba，求这个数
15. 硬币兑换最小数
16. 两个排序的数组A和B分别含有m和n个数，找到两个排序数组的中位数，要求时间复杂度应为O(log (m+n))。
17. 最长公共子序列
18. 最长上升子序列
19. 最大子段和
20. 无序数组求中位数
21. 数组中超过一半的数字