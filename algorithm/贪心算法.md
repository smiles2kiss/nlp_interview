### 一. 从一道Leetcode题目说起

#### 1. Leetcode 55 (跳跃游戏)

##### (1) 题目描述

给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。

示例 1:

```
输入: [2,3,1,1,4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
```

示例 2:

```
输入: [3,2,1,0,4]
输出: false
解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。
```

##### (2) 初始解法

暴力穷举，举出所有可能到达的位置，算法复杂度太高，不适合。

**(3) 基本思路**:

接下来，我们来考虑第一种情况，以数组data = [2, 3, 1, 1, 4]为例，假设我们从数组的最后一个位置往前看

* 首先考虑从**index为4**的位置 跳到 数组**index 为0**的位置所需要的最大跳跃长度为4，即需要满足data[0] > = 4 - 0，很明显不满足
* 接着考虑从**index为4**的位置 跳到 数组**index为1**的位置所需要的最大跳跃长度为3，即需要满足data[1] >= 4 - 1 = 3，满足条件；然后考虑从**index为1**的位置 跳到 数组**index为0**的位置所需要的最大条约长度为1，即需要满足data[0] >= 1 - 1 = 1，满足条件，结束
* 否则
* 接着考虑从**index为4**的位置 跳到 数组**index为2**的位置所需要的最大跳跃长度为2，即需要满足data[2] >= 4 - 2 = 2，。。。

从上述过程，我们可以看到，本质上这道题是初始化最大跳跃长度为4，尝试从数组的最后一个位置跳4步跳回到**index为0**的位置，如果起点能够跳到起点，则结束。如果不能满足，将最大跳跃长度减1，尝试从数组的最后一个位置跳3步跳回到index为1的位置，再从index为1的位置跳回到index为0的位置，满足则结束；否则最大长度继续减1，直到得到最后的结果，或者不能满足条件。

(4) C++ 代码实现



