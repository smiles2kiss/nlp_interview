## 动态规划算法

### 一. LeetCode 53

#### 1. 题目描述

Leetcode53 最大子序和

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

```
输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

#### 2. 基本思路

利用动态规划的思想，思考转移方程，设最大连续子数组和为max[num]

初始化max[0] = nums[0]

如果nums[i] + max[i - 1] > nums[i]，则max[i] = nums[i] + max[i - 1]

否则max[i] = nums[i] 

即可完成解答

#### 3. 进阶思路

能否想到时间复杂度为O(n)的算法，利用分治法考虑

#### 4. C++代码实现

见[../cpp_code/leetcode_53.cpp](../cpp_code/leetcode_53.cpp)

### 二. LeetCode 5

#### 1. 题目描述

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

示例 1：

```
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
```

示例 2：

```
输入: "cbbd"
输出: "bb"
```

#### 2. 基本思路

遍历，在每个节点处判断左右两边能否的字符串能否满足要求

#### 3. 进阶思路

假设更改题目为求最长的回文子串的长度，这道题是不是和最大子序和这道题类似，只是其中的判断条件不同，因此我们需要实现一个时间复杂度较低的判断回文字符串的函数。

设&emsp;  $dp[i][j]$&emsp;代表从字符串&emsp; $[i,\ j]$&emsp;范围内的子串，能否构成回文串

转换方程如下

##### (0) 初始设置为

$$dp[0][0] = 1，dp[i][i] = 1$$

##### (1) 即长度小于2的字符串都满足回文串

$if \  (j - i < 2):$

&emsp;&emsp;$dp[i][j] = 1$ 

##### (2) 长度大于2的字符串需要满足3个条件

$if \ (j - i >= 2 \quad and \quad  s[i] == s[j] \quad  and \quad  dp[i + 1][j - 1] == 1):$

&emsp;&emsp;$dp[i][j] = 1$

#### 4. 代码实现

见[cpp_code/leetcode_5_dp.cpp](../cpp_code/leetcode_5_dp.cpp)

#### 5. 终极算法

马拉车算法