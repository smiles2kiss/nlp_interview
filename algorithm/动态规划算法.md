## 动态规划算法

https://blog.csdn.net/qq_1932568757/article/details/82725132

* 数位dp
* 区间dp
* 树形dp
* 插头dp
* 概率dp
* 状态压缩dp

### 一. LeetCode 53

#### 1. 题目描述

Leetcode53 最大子序和

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

```
输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

#### 2. 基本思路

利用动态规划的思想，思考转移方程，设最大连续子数组和为max[num]

初始化$max[0] = nums[0]$

如果$nums[i] + max[i - 1] > nums[i]$，则$max[i] = nums[i] + max[i - 1]$

否则$max[i] = nums[i]$

即可完成解答

#### 3. 进阶思路

能否想到时间复杂度为O(n)的算法，利用分治法考虑

#### 4. C++代码实现

见[../cpp_code/leetcode_53.cpp](../cpp_code/leetcode_53.cpp)

### 二. LeetCode 5

#### 1. 题目描述

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

示例 1：

```
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
```

示例 2：

```
输入: "cbbd"
输出: "bb"
```

#### 2. 基本思路

遍历，在每个节点处判断左右两边能否的字符串能否满足要求

#### 3. 进阶思路

假设更改题目为求最长的回文子串的长度，这道题是不是和最大子序和这道题类似，只是其中的判断条件不同，因此我们需要实现一个时间复杂度较低的判断回文字符串的函数。

设&emsp;  $dp[i][j]$&emsp;代表从字符串&emsp; $[i,\ j]$&emsp;范围内的子串，能否构成回文串

转换方程如下

##### (0) 初始设置为

$dp[0][0] = 1，dp[i][i] = 1$

##### (1) 即长度小于2的字符串都满足回文串

$if \  (j - i < 2):$

&emsp;&emsp;$dp[i][j] = 1$ 

##### (2) 长度大于2的字符串需要满足3个条件

$if \ (j - i >= 2 \quad and \quad  s[i] == s[j] \quad  and \quad  dp[i + 1][j - 1] == 1):$

&emsp;&emsp;$dp[i][j] = 1$

#### 4. 代码实现

见[cpp_code/leetcode_5_dp.cpp](../cpp_code/leetcode_5_dp.cpp)

#### 5. 终极算法

马拉车算法

### 三. 编辑距离

#### 1. 基本思路

**解决两个字符串的动态规划问题，一般都是用两个指针** **`i,j`** **分别指向两个字符串的最后，然后一步步往前走，缩小问题的规模**。

#### 2. 代码实现

见[cpp_code/leetcode_72.cpp](../cpp_code/leetcode_72.cpp)

### 四. 高楼扔鸡蛋

你面前有一栋从 1 到 `N` 共 `N` 层的楼，然后给你 `K` 个鸡蛋（`K` 至少为 1）。现在确定这栋楼存在楼层 `0 <= F <= N`，在这层楼将鸡蛋扔下去，鸡蛋**恰好没摔碎**（高于 `F` 的楼层都会碎，低于 `F` 的楼层都不会碎）。现在问你，**最坏**情况下，你**至少**要扔几次鸡蛋，才能**确定**这个楼层 `F` 呢？

#### 1. 考虑鸡蛋数量是无限的情况

##### (1) 线性扫描

从第一楼扔到第N层楼。

* 如果从第1层楼扔，鸡蛋碎了，则F=0，如果鸡蛋没碎，则继续在第2层楼扔，...，

* 在第N层楼，如果鸡蛋碎了，F=N-1，如果鸡蛋没碎，则F=N。

##### (2) 二分查找

假设有7层楼，则设置 start = 1，end = 7

先去第 `(1 + 7) / 2 = 4` 层扔一下

* 如果碎了说明 `F` 小于 4，去第 `(1 + 3) / 2 = 2` 层试
* 如果没碎说明 `F` 大于 4，取第 `(5 + 7) / 2 = 6 层试

