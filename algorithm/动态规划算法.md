## 动态规划算法

### 一. LeetCode 53

#### 1. 题目描述

Leetcode53 最大子序和

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

```
输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

#### 2. 基本思路

利用动态规划的思想，思考转移方程，设最大连续子数组和为max[num]

初始化$max[0] = nums[0]$

如果$nums[i] + max[i - 1] > nums[i]$，则$max[i] = nums[i] + max[i - 1]$

否则$max[i] = nums[i]$

即可完成解答

#### 3. 进阶思路

能否想到时间复杂度为O(n)的算法，利用分治法考虑

#### 4. C++代码实现

见[../cpp_code/leetcode_53.cpp](../cpp_code/leetcode_53.cpp)

### 二. LeetCode 5

#### 1. 题目描述

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

示例 1：

```
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
```

示例 2：

```
输入: "cbbd"
输出: "bb"
```

#### 2. 基本思路

遍历，在每个节点处判断左右两边能否的字符串能否满足要求

#### 3. 进阶思路

假设更改题目为求最长的回文子串的长度，这道题是不是和最大子序和这道题类似，只是其中的判断条件不同，因此我们需要实现一个时间复杂度较低的判断回文字符串的函数。

设&emsp;  $dp[i][j]$&emsp;代表从字符串&emsp; $[i,\ j]$&emsp;范围内的子串，能否构成回文串

转换方程如下

##### (0) 初始设置为

$dp[0][0] = 1，dp[i][i] = 1$

##### (1) 即长度小于2的字符串都满足回文串

$if \  (j - i < 2):$

&emsp;&emsp;$dp[i][j] = 1$ 

##### (2) 长度大于2的字符串需要满足3个条件

$if \ (j - i >= 2 \quad and \quad  s[i] == s[j] \quad  and \quad  dp[i + 1][j - 1] == 1):$

&emsp;&emsp;$dp[i][j] = 1$

#### 4. 代码实现

见[cpp_code/leetcode_5_dp.cpp](../cpp_code/leetcode_5_dp.cpp)

#### 5. 终极算法

马拉车算法

### 三. Leetcode 72

```
class Solution {
public:
    int minDistance(string word1, string word2) {
        int len1 = word1.length();
        int len2 = word2.length();
        if (len1 == 0)
            return len2;
        if (len2 == 0)
            return len1;

        int distance[len1 + 1][len2 + 1];
        distance[0][0] = 0;
        for (int i = 1; i <= len1; i++) {
            distance[i][0] = i;
        }
        for (int j = 1; j <= len2; j++) {
            distance[0][j] = j;
        }

        for (int i = 1; i <= len1; i++) {
            for (int j = 1; j <= len2; j++) {
                if (word1[i - 1] == word2[j - 1]) {
                    distance[i][j] = distance[i - 1][j - 1];
                } else {
                    int min = i > j ? i : j;
                    if (distance[i - 1][j - 1] + 1 < min) { // 替换
                        min = distance[i - 1][j - 1] + 1;
                    }
                    if (distance[i - 1][j] + 1 < min) { // 插入
                        min = distance[i - 1][j] + 1;
                    }
                    if (distance[i][j - 1] + 1 < min) { // 删除
                        min = distance[i][j - 1] + 1;
                    }
                    distance[i][j] = min;
                }
            }
        }
        return distance[len1][len2];
    }
};
```

