## 二叉树

### 一. 二叉树的遍历

#### 1. 二叉树的结构体

```c++
struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x): val(x), left(NULL), right(NULL) {};
};
```

#### 2. 二叉树的递归遍历

本质上可看作一种深度优先搜索(DFS)

##### (1) 先序遍历

###### a. 递归实现

```c++
// 先序遍历二叉树
void preOrder(TreeNode* root) {
	if (root != NULL) {
		cout << root->val << endl;
		preOrder(root->left);
		preOrder(root->right);
	}
} 
```

###### b. 非递归实现

```c++
// 非递归先序遍历二叉树 
void preOrder_non_recursive(TreeNode* root) {
	if (root == NULL)
		return;
	
	TreeNode* p = root;
	stack<TreeNode*> s;
	while (!s.empty() || p) {
		if (p) {
			cout << p->val << "\t";
			s.push(p);
			p = p->left;
		} else {
			p = s.top();
			s.pop();
			p = p->right;
		}
	}
	cout << endl;
} 
```

更简单的写法

```c++
void preOrder_non_recursive2(TreeNode* root) {
	if (root == NULL)
		return;
	
	stack<TreeNode*> s;
	TreeNode* p = root;
	while (!s.empty() || p) {
		while(p) {
			cout << p->val << "\t";
			s.push(p);
			p = p->left;
		}
		p = s.top();
		s.pop();
		p = p->right;
	}
	cout << endl;
}
```

##### (2) 中序遍历

###### a. 递归实现

```c++
// 中序遍历二叉树
 void inOrder(TreeNode* root) {
	if (root != NULL) {
		inOrder(root->left);
		cout << root->val << endl;
		inOrder(root->right);
	}
} 
```

###### b. 非递归实现

```c++
// 非递归中序遍历二叉树 
void inOrder_non_recursive(TreeNode* root) {
	if (root == NULL)
		return;
	
	TreeNode* p = root;
	stack<TreeNode*> s;
	while (!s.empty() || p) {
		if (p) {
			s.push(p);
			p = p->left;
		} else {
			p = s.top();
			cout << p->val << "\t";
			s.pop();
			p = p->right;
		}
	} 
	cout << endl;
}
```

更简单的实现方法

```c++
void inOrder_non_recursive2(TreeNode* root) {
	if (root == NULL)
		return;
	
	TreeNode* p = root;
	stack<TreeNode*> s;
	while (!s.empty() || p) {
		while (p) {
			s.push(p);
			p = p->left;
		}
		p = s.top();
		cout << p->val << "\t";
		s.pop();
		p = p->right;
	}
	cout << endl;
} 
```

##### (3) 后序遍历

###### a. 递归实现

```c++
// 后序遍历二叉树
void postOrder(TreeNode* root) {
	if (root != NULL) {
		postOrder(root->left);
		postOrder(root->right);
		cout << root->val << endl;z
	}
}
```

###### b. 非递归实现

```c++
// 非递归后序遍历二叉树 
void postOrder_non_recursive(TreeNode* root) {
	if (root == NULL)
		return;
	
	stack<TreeNode*> s;
	TreeNode* p = root;
	TreeNode* last = root;
	while (p) {
		s.push(p);
		p = p->left;
	}	

	while (!s.empty()) {
		p = s.top();
		s.pop();
		if (p->right == NULL || p->right == last) {
			cout << p->val << "\t";
			last = p;
			p = NULL;
		} else {
			s.push(p);
			p = p->right;
			while (p) {
				s.push(p);
				p = p->left;
			}	
		}
	}
	cout << endl; 
}
```

更简单的写法

```c++
void postOrder_non_recursive2(TreeNode* root) {
	if (root == NULL)
		return;
	
	TreeNode* p = root;
	TreeNode* last = root; 
	stack<TreeNode*> s;
	while (!s.empty() || p) {
		while(p) {
			s.push(p);
			p = p->left;
		}
		
		// 每次访问栈顶的p 
		p = s.top();
		if (p->right == NULL || p->right == last) {
			// 右子树为空，或者 右子树已经被访问过，元素出栈 
			cout << p->val << "\t";
			s.pop();
			last = p;
			p = NULL;
		} else {
			p = p->right; // 访问右子树节点 
		}
	}
	cout << endl;
}

```

#### 3. 二叉树的非递归遍历

本质上可看作一种宽度优先搜索(BFS)

##### (1) 层次遍历

```c++
// 层次遍历二叉树
void levelOrder(TreeNode* root) {
	if (root == NULL)
		return;

	queue<TreeNode*> q;
	q.push(root);
	int count = 1;
	while (!q.empty()) {
		while (count > 0) {				
			TreeNode* front = q.front();
			cout << front->val << "\t";;
			q.pop();
			count = count - 1;
			
			if (front->left != NULL)
				q.push(front->left);
			if (front->right != NULL)
				q.push(front->right);
		}
		count = q.size();
	}
}
```

### 二. 二叉树的构造

#### 1. 二叉树的结构体

```c++
struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x): val(x), left(NULL), right(NULL) {};
};
```

#### 2. 先序遍历顺序构造二叉树

##### (1) 错误思路

此时root会返回最后赋值的那个节点，而并非根节点

```c++
// 先序遍历构造二叉树
TreeNode* Construct_Tree(TreeNode* root, vector<int> nums) {
	int data = nums[index];
	index++;
	
	if (data == -1) {
		root = NULL;
	} else {
		// 重新声明局部变量 
		root = new TreeNode(data);
		Construct_Tree(root->left, nums);
		Construct_Tree(root->right, nums);
	}
}
```

##### (2) 正确思路

```c++
// 先序遍历构造二叉树
TreeNode* Construct_Tree(TreeNode* root, vector<int> nums) {
	int data = nums[index];
	index++;
	
	if (data == -1) {
		return NULL;
	} else {
		// 重新声明局部变量 
		root = new TreeNode(data);
		root->left = Construct_Tree(root->left, nums);
		root->right = Construct_Tree(root->right, nums);
		return root;
	}
}
```

```c++
int main() {
	TreeNode* root;
	vector<int> nums = vector<int>({3, 4, 7, -1, -1, 8, -1, -1, 1, -1, -1});
    root = Construct_Tree(root, nums);
	cout << endl << "preOrder: ";
	preOrder(root);
	cout << endl << "inOrder: ";
	inOrder(root);
	cout << endl << "postOrder: ";
	postOrder(root);
	cout << endl << "levelOrder: ";
	levelOrder(root);
}
```

